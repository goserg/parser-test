#### Заметки о задаче
1. Вопрос: есть ли необходимость в случае с numeric значениями как в "Bar.Alpha = 7" преобразовать "7" тип string в numeric тип для передачи в squirrel.Eq{}? Повлияет ли это на результирующий SQL запрос? Протестировав SQL запросы для базы данных Postgresql, я не заметил разницы между запросами типа "... WHERE aa=7;" и "... WHERE aa='7';". Кроме того документации postgresql я не нашел указание на то, что нельзя передавать numeric тип в одиночных кавычках. Аналогично для булевых значений. Принял решение для упрощения парсера передавать любые значения в виде строки.
2. При разработке парсера были приняты следующие допущения:
    - ~~в названиях колонок не содержится пробелов;~~
    - ~~названия колонок записываются без двойных кавычек;~~
    - ~~в значениях не содержится пробелов;~~
    - все условные операторы и операторы сравнения окружены пробелами;
    - группировка скобками отсутсвует.

Данные допущения были приняты во избежание чрезмерного усложения парсера. Запросы вида Field1='foo'AND"Field2"!=7OR"Field3">11.7 парсером распознаваться не будут.

3. Проверка соответствия типов колонки и значения?? Считаю, что в зону ответственности парсера не должна входить обязаность опрашивать БД и выяснять, какой тип данных хранится в колонках таблицы. Кроме того, я не вижу возможности для этого, так как в сигнатуре парсера: Parse(query string, qb squirrel.SelectBuilder)(*squirrel.SelectBuilder, error) нет ссылки ни на базу данных, ни на какую-либо callback функцию, чтобы запросить из базы data_type колонки.
4. Проверка валидности имени колонки. Согласно документации Postgresql глава 4.1, параграф 4.1.1 Идентификаторы и ключевые слова: Идентификаторы должны начинаться с буквы или знака подчеркивания. Следующие символы должны быть буквами, знаками подчеркивания, цифрами или знаком $. Согласно требованиям к ТЗ на парсер дополнительно могут быть включены точки. Нет уточнения в каких позициях, исходя из примера Foo.Bar.Alpha делаю вывод - точки в качестве разделителей, не первым символом. Если идентификатор окружен двойными кавычками, то он может состоять из любых символов кроме нулевого.

#### ТЗ

Написать простой парсер WHERE части запросов SQL.

Парсер должен:
- иметь сигнатуру Parse(query string, qb squirrel.SelectBuilder)(*squirrel.SelectBuilder, error)
- уметь разбирать пользовательский ввод вида Field1 = "foo" AND Field2 != 7 OR Field3 > 11.7
- поддерживать синтаксис PostgreSQL;
- поддерживать точки в имени колонки - Foo.Bar.Alpha;
- вызывать callback-обработчик для проверки валидности имени колонки и соответствия типов колонки и значения, возможная сигнатура обработчика - func(colName string, value interface{}) error
- обрабатывать только блок условий WHERE, то есть возвращать в ошибку в случае если во входной строке есть другие выражения SQL, как то LIMIT, ORDER BY и др.
- в случае успеха разбора и проверки входных условий - формировать WHERE условия для qb squirrel.SelectBuilder вида qb =
qb.Where(squirrel.Eq{left: val})
- возвращать qb дополненный выражениями извлечёнными из пользовательского ввода query

При желании можно решить задание повышенной сложности - пользовательский ввод разбирать парсером SQL от CockroachDB. Пример работы с парсером можно посмотреть в https://github.com/cockroachdb/cockroach-gen/blob/master/pkg/sql/parser/parse_test.go

Для импорта парсера как зависимости потребуется сделать форк исходного репозитория и значимо урезать содержимое репозитория, оставив лишь необходимые для работы парсера части кода.

Тестовые примеры для работы парсера:

- Foo.Bar.X = 'hello'
- Bar.Alpha = 7
- Foo.Bar.Beta > 21 AND Alpha.Bar != 'hello'
- Alice.IsActive AND Bob.LastHash = 'ab5534b'
- Alice.Name ~ 'A.*' OR Bob.LastName !~ 'Bill.*'
